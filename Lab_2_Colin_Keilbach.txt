//Code by: Colin Keilbach

//In c++
// using color = vec3;
//In GLSL
#define colorRGB    vec3
#define colorRGBA   vec4

//Make a gradient
vec4 myEffect0(in vec2 fragCoord, in vec2 resolution){
    
    vec4 returnColor = vec4(1.0, 0.0, 0.0, 0.0); //Returns red when there is no other effect
    
    //Change color
    //R -> Horizontal
    //G -> Vertical
    //B?
    //A?
    //returnColor = vec4(fragCoord, 0.0, 1.0);
    
    vec2 uv = fragCoord/resolution; //converts the fragCoord variables to a number between 0 - 1
    
    //returnColor = vec4(uv, 0.25, 1.0);
    
    vec3 color = vec3(uv, 0.25);
    float alpha = 1.0;
    
    returnColor = vec4(color, alpha);
    
    return returnColor;
}

//out reference for the output instead of returning something normally
void mainImage( out vec4 fragColor, in vec2 fragCoord ) //FragCoord is the current pixel
{
    //R, G, B, A = Red, Green, Blue, Alpha
    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);
    //Can also be ran
    //fragColor = vec4(1.0);
    //Because it is running the same variable for each
    
    
    fragColor = myEffect0(fragCoord, iResolution.xy); //Creates a static gradient
    
    //Arrays
    //float myArray[6] = float[6](1.0, 2.0, 3.0, 3.0, 4.0, 5.0, 6.0);
    //myArray[0] = 1.0;
    
    //GLSL automatically converts double to float
    
/*
    // Normalized pixel coordinates (from 0 to 1)
    vec2 uv = fragCoord/iResolution.xy; //u is horizontal, v is vertical

    // Time varying pixel color
    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));

    // Output to screen
    fragColor = vec4(col,1.0);
*/
}